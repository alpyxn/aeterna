package services

import (
	"errors"
	"time"

	"github.com/alpyxn/aeterna/backend/internal/database"
	"github.com/alpyxn/aeterna/backend/internal/models"
	"gorm.io/gorm"
)

type MessageService struct{}

var cryptoService = CryptoService{}
var msgValidationService = ValidationService{}
var msgFileService = FileService{}
var msgSettingsService = SettingsService{}

func (s MessageService) Create(content, recipientEmail string, triggerDuration int, reminders []int) (models.Message, error) {
	// Validate SMTP configuration before creating switch
	settings, err := msgSettingsService.Get()
	if err != nil {
		return models.Message{}, err
	}
	if settings.SMTPUser == "" || settings.SMTPHost == "" {
		return models.Message{}, BadRequest("SMTP_NOT_CONFIGURED: SMTP is not configured. Please go to Settings to configure your email server.", nil)
	}

	if err := msgSettingsService.TestSMTP(settings); err != nil {
		return models.Message{}, BadRequest("SMTP_CONNECTION_FAILED: SMTP connection test failed. Please check your email settings.", err)
	}

	// Validate trigger duration
	if err := msgValidationService.ValidateTriggerDuration(triggerDuration); err != nil {
		return models.Message{}, err
	}

	// Validate and sanitize content
	if err := msgValidationService.ValidateContent(content); err != nil {
		return models.Message{}, err
	}

	// Validate email format
	if err := msgValidationService.ValidateEmail(recipientEmail); err != nil {
		return models.Message{}, err
	}

	encrypted, err := cryptoService.Encrypt(content)
	if err != nil {
		return models.Message{}, err
	}

	msg := models.Message{
		Content:     encrypted,
		KeyFragment: "v1",
		// ID and ManagementToken will be auto-generated by BeforeCreate hook
		RecipientEmail:  recipientEmail,
		TriggerDuration: triggerDuration,
		LastSeen:        time.Now(),
		Status:          models.StatusActive,
	}

	err = database.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(&msg).Error; err != nil {
			return Internal("Failed to create message", err)
		}

		for _, minutesBefore := range reminders {
			reminder := models.MessageReminder{
				MessageID:     msg.ID,
				MinutesBefore: minutesBefore,
				Sent:          false,
			}
			if err := tx.Create(&reminder).Error; err != nil {
				return Internal("Failed to create reminder", err)
			}
			msg.Reminders = append(msg.Reminders, reminder)
		}
		return nil
	})

	if err != nil {
		return models.Message{}, err
	}

	// Return decrypted content for API consumers
	msg.Content = content
	return msg, nil
}

func (s MessageService) GetByID(id string) (models.Message, error) {
	var msg models.Message
	if err := database.DB.Preload("Reminders").First(&msg, "id = ?", id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return models.Message{}, NotFound("Message not found", err)
		}
		return models.Message{}, Internal("Failed to fetch message", err)
	}
	decrypted, err := cryptoService.Decrypt(msg.Content)
	if err != nil {
		return models.Message{}, err
	}
	msg.Content = decrypted

	// Include attachment count
	count, _ := msgFileService.CountByMessageID(id)
	msg.AttachmentCount = count

	return msg, nil
}

func (s MessageService) List() ([]models.Message, error) {
	var messages []models.Message
	if err := database.DB.Preload("Reminders").Order("created_at DESC").Find(&messages).Error; err != nil {
		return nil, Internal("Failed to fetch messages", err)
	}
	for i := range messages {
		decrypted, err := cryptoService.Decrypt(messages[i].Content)
		if err != nil {
			return nil, err
		}
		messages[i].Content = decrypted

		// Include attachment count
		count, _ := msgFileService.CountByMessageID(messages[i].ID)
		messages[i].AttachmentCount = count
	}
	return messages, nil
}

func (s MessageService) Heartbeat(id string) (models.Message, error) {
	var msg models.Message
	if err := database.DB.First(&msg, "id = ?", id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return models.Message{}, NotFound("Message not found", err)
		}
		return models.Message{}, Internal("Failed to fetch message", err)
	}

	if msg.Status == models.StatusTriggered {
		return models.Message{}, BadRequest("Cannot send heartbeat to a triggered message. The message has already been delivered.", nil)
	}

	msg.LastSeen = time.Now()
	if err := database.DB.Save(&msg).Error; err != nil {
		return models.Message{}, Internal("Failed to update heartbeat", err)
	}

	return msg, nil
}

func (s MessageService) Delete(id string) error {
	var msg models.Message
	if err := database.DB.First(&msg, "id = ?", id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return NotFound("Message not found", err)
		}
		return Internal("Failed to fetch message", err)
	}

	// Delete all attachments (files + DB records) first
	if err := msgFileService.DeleteByMessageID(id); err != nil {
		return Internal("Failed to delete attachments", err)
	}

	if err := database.DB.Unscoped().Delete(&msg).Error; err != nil {
		return Internal("Failed to delete message", err)
	}

	return nil
}

func (s MessageService) Update(id, content string, triggerDuration int, reminders []int) (models.Message, error) {
	var msg models.Message
	if err := database.DB.First(&msg, "id = ?", id).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return models.Message{}, NotFound("Message not found", err)
		}
		return models.Message{}, Internal("Failed to fetch message", err)
	}

	// Cannot edit triggered messages
	if msg.Status == models.StatusTriggered {
		return models.Message{}, BadRequest("Cannot edit a triggered message. The message has already been delivered.", nil)
	}

	// Validate content
	if err := msgValidationService.ValidateContent(content); err != nil {
		return models.Message{}, err
	}

	// Validate trigger duration
	if err := msgValidationService.ValidateTriggerDuration(triggerDuration); err != nil {
		return models.Message{}, err
	}

	// Encrypt the new content
	encrypted, err := cryptoService.Encrypt(content)
	if err != nil {
		return models.Message{}, err
	}

	// Update fields
	msg.Content = encrypted
	msg.TriggerDuration = triggerDuration
	msg.LastSeen = time.Now()
	err = database.DB.Transaction(func(tx *gorm.DB) error {
		// Update msg fields
		if err := tx.Save(&msg).Error; err != nil {
			return Internal("Failed to update message", err)
		}

		// Delete old reminders
		if err := tx.Where("message_id = ?", msg.ID).Delete(&models.MessageReminder{}).Error; err != nil {
			return Internal("Failed to delete old reminders", err)
		}

		// Create new reminders
		msg.Reminders = []models.MessageReminder{}
		for _, minutesBefore := range reminders {
			reminder := models.MessageReminder{
				MessageID:     msg.ID,
				MinutesBefore: minutesBefore,
				Sent:          false,
			}
			if err := tx.Create(&reminder).Error; err != nil {
				return Internal("Failed to create new reminder", err)
			}
			msg.Reminders = append(msg.Reminders, reminder)
		}

		return nil
	})

	if err != nil {
		return models.Message{}, err
	}

	// Return decrypted content for API consumers
	msg.Content = content
	return msg, nil
}
